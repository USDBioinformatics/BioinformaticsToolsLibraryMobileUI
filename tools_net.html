<!DOCTYPE html>
<html>
<head>
<title>Bioinformatics Tools Library</title>
<link href='http://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
<link href='index_grid.css' rel='stylesheet' type='text/css'>
<link href="css/sample.css" rel='stylesheet' type='text/css'>
 <style type="text/css">
    body {
      font: 10pt arial;
    }
    #mynetwork {

      width: 100%;
      height: 700px;
      border: 1px solid lightgray;
      background-color:#858585 ;
    }
  </style>

<link href="css/sample.css" rel='stylesheet' type='text/css'>
<link href="css/jquery.treeview.css" rel='stylesheet' type='text/css'>

  <script type="text/javascript" src="./dist/vis.js"></script>
  <link href="./vis.css" rel="stylesheet" type="text/css" />
<script type="text/javascript"> 
//=--------------------------------------------------------------=
var dataBefore = [
        {
            "name": "abyss-pe",
            "display_name": "Abyss Paired-End",
            "version": "1.0.0",
            "summary": "\n**What it does**\n\nABySS is a de novo, paired-end sequence assembler that is designed for short reads. \n\n**Input**\n\nThe suffix of the read identifier for a pair of reads must be one of '1' and '2', or 'A' and 'B', or 'F' and 'R', or 'F3' and 'R3', or 'forward' and 'reverse'. The reads may be interleaved in the same file or found in different files; however, interleaved mates will use less memory.\n\n**Description**\n\nThis tool performs the following commands:\n\nABYSS - the single-end assembler\nAdjList - finds overlaps of length k-1 between contigs\nKAligner** - aligns reads to contigs\nParseAligns** - finds pairs of reads in alignments\nDistanceEst** - estimates distances between contigs\nOverlap - find overlaps between blunt contigs\nSimpleGraph - finds paths between pairs of contigs\nMergePaths - merges consistent paths\nConsensus - for a colour-space assembly, convert the colour-space contigs to nucleotide contigs\n\n**Reference**\n\nhttp://www.bcgsc.ca/platform/bioinfo/software/abyss\n",
            "description": "Assemble short paired reads",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        },
        {
            "name": "abyss",
            "display_name": "Abyss",
            "version": "1.0.0",
            "summary": "\n**What it does**\n\nABySS is a de novo sequence assembler that is designed for short reads.\n\n.. image:: http://www.bcgsc.ca/platform/bioinfo/software/abyss/screenshot\n\n**Reference**\n\nhttp://www.bcgsc.ca/platform/bioinfo/software/abyss\n",
            "description": "Assemble short unpaired reads",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        },
        {
            "name": "WigAdd",
            "display_name": "Add",
            "version": "1.1.0",
            "summary": "\n  \nThis tool will add all values in the specified Wig files base pair by base pair.\n  \n.. class:: infomark\n\n**TIP:** If your dataset does not appear in the pulldown menu, it means that it is not in Wig or BigWig format. Use \"edit attributes\" to set the correct format if it was not detected correctly.\n   \n",
            "description": "multiple (Big)Wig files",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        },
        {
            "name": "gd_add_fst_column",
            "display_name": "Per-SNP FSTs",
            "version": "1.2.0",
            "summary": "\n\n**Dataset formats**\n\nThe input datasets are in gd_snp_, gd_genotype_, and gd_indivs_ formats.\nThe output dataset is in gd_snp_ or gd_genotype_ format.  (`Dataset missing?`_)\n\n.. _gd_snp: ./static/formatHelp.html#gd_snp\n.. _gd_genotype: ./static/formatHelp.html#gd_genotype\n.. _gd_indivs: ./static/formatHelp.html#gd_indivs\n.. _Dataset missing?: ./static/formatHelp.html\n\n-----\n\n**What it does**\n\nThe user specifies a SNP table and two \"populations\" of individuals, both previously defined using the Galaxy tool to specify individuals from a SNP table. No individual can be in both populations. Other choices are as follows.\n\nFrequency metric. The allele frequencies of a SNP in the two populations can be estimated either by the total number of reads of each allele (if the table is in gd_snp format, but not with gd_genotype), or by adding the frequencies inferred from genotypes of individuals in the populations.\n\nAfter specifying the frequency metric, the user sets lower bounds on amount of data required at a SNP. For estimating the Fst using read counts, the bound is the minimum count of reads of the two alleles in a population. For estimations based on genotype, the bound is the minimum reported genotype quality per individual.\n\nThe user specifies whether the SNPs that violate the lower bound should be ignored or the Fst set to -1.\n\nThe user specifies whether SNPs where both populations appear to be fixed for the same allele should be retained or discarded.\n\nFinally, the user chooses which definition of Fst to use: Wright's original definition, the Weir-Cockerham unbiased estimator, or the Reich-Patterson estimator.\n\nA column is appended to the SNP table giving the Fst for each retained SNP.\n\nReferences:\n\nSewall Wright (1951) The genetical structure of populations. Ann Eugen 15:323-354.\n\nWeir, B.S. and Cockerham, C. Clark (1984) Estimating F-statistics for the analysis of population structure. Evolution 38:1358-1370.\n\nWeir, B.S. 1996. Population substructure. Genetic data analysis II, pp. 161-173. Sinauer Associates, Sundand, MA.\n\nDavid Reich, Kumarasamy Thangaraj, Nick Patterson, Alkes L. Price, and Lalji Singh (2009) Reconstructing Indian population history. Nature 461:489-494, especially Supplement 2.  \n\nTheir effectiveness for computing FSTs when there are many SNPs but few individuals is discussed in the following paper.\n\nEva-Maria Willing, Christine Dreyer, Cock van Oosterhout (2012) Estimates of genetic differentiation measured by FST do not necessarily require large sample sizes when using many SNP markers. PLoS One 7:e42649.\n\n-----\n\n**Example**\n\n- input, SNP table::\n\n   #{\"column_names\":[\"scaf\",\"pos\",\"A\",\"B\",\"qual\",\"ref\",\"rpos\",\"rnuc\",\"1A\",\"1B\",\"1G\",\"1Q\",\"2A\",\"2B\",\"2G\",\"2Q\",\"3A\",\"3B\",\"3G\",\"3Q\",\"4A\",\"4B\",\"4G\",\"4Q\",\n   #\"5A\",\"5B\",\"5G\",\"5Q\",\"6A\",\"6B\",\"6G\",\"6Q\",\"pair\",\"dist\",\"prim\",\"rflp\"],\"dbkey\":\"canFam2\",\n   #\"individuals\":[[\"PB1\",9],[\"PB2\",13],[\"PB3\",17],[\"PB4\",21],[\"PB6\",25],[\"PB8\",29]],\n   #\"pos\":2,\"rPos\":7,\"ref\":6,\"scaffold\":1,\"species\":\"bear\"}\n   Contig161_chr1_4641264_4641879    115  C  T  73.5  chr1  4641382  C  6  0  2  45  8  0  2  51  15  0  2  72  5  0  2  42  6  0  2  45  10  0  2  57  Y  54   0.323  0\n   Contig113_chr5_11052263_11052603  28   C  T  38.2  chr5  11052280 C  1  2  1  12  3  2  1  10  5   0  2  42  2  1  2  13  3  0  2  36  8   0  2  51  Y  161  +99.   0\n   Contig215_chr5_70946445_70947428  363  T  G  28.2  chr5  70946809 C  4  0  2  39  0  5  0  12  9   0  2  54  6  0  2  45  3  3  2  1   9   0  2  54  N  43   0.153  0\n   etc.\n\n- input, Population 1 individuals::\n\n   9       PB1\n   13      PB2\n\n- input, Population 2 individuals::\n\n   17      PB3\n   21      PB4\n\n- output (minimum read count of 3, discard fixed)::\n\n   Contig113_chr5_11052263_11052603  28   C  T  38.2  chr5  11052280  C  1  2  1  12  3  2  1  10  5  0  2  42  2  1  2  13  3  0  2  36  8  0  2  51  Y  161  +99.   0  0.1636\n   Contig215_chr5_70946445_70947428  363  T  G  28.2  chr5  70946809  C  4  0  2  39  0  5  0  12  9  0  2  54  6  0  2  45  3  3  2  1   9  0  2  54  N  43   0.153  0  0.3846\n   etc.\n\n  ",
            "description": ": Compute a fixation index score for each SNP",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        },
        {
            "name": "add_taxa",
            "display_name": "add_taxa",
            "version": "1.2.0",
            "summary": "\n  \n ",
            "description": "Add taxa to OTU table",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        },
        {
            "name": "abyss-pe",
            "display_name": "Abyss Paired-End",
            "version": "1.0.0",
            "summary": "\n**What it does**\n\nABySS is a de novo, paired-end sequence assembler that is designed for short reads. \n\n**Input**\n\nThe suffix of the read identifier for a pair of reads must be one of '1' and '2', or 'A' and 'B', or 'F' and 'R', or 'F3' and 'R3', or 'forward' and 'reverse'. The reads may be interleaved in the same file or found in different files; however, interleaved mates will use less memory.\n\n**Description**\n\nThis tool performs the following commands:\n\nABYSS - the single-end assembler\nAdjList - finds overlaps of length k-1 between contigs\nKAligner** - aligns reads to contigs\nParseAligns** - finds pairs of reads in alignments\nDistanceEst** - estimates distances between contigs\nOverlap - find overlaps between blunt contigs\nSimpleGraph - finds paths between pairs of contigs\nMergePaths - merges consistent paths\nConsensus - for a colour-space assembly, convert the colour-space contigs to nucleotide contigs\n\n**Reference**\n\nhttp://www.bcgsc.ca/platform/bioinfo/software/abyss\n",
            "description": "Assemble short paired reads",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        },
        {
            "name": "abyss",
            "display_name": "Abyss",
            "version": "1.0.0",
            "summary": "\n**What it does**\n\nABySS is a de novo sequence assembler that is designed for short reads.\n\n.. image:: http://www.bcgsc.ca/platform/bioinfo/software/abyss/screenshot\n\n**Reference**\n\nhttp://www.bcgsc.ca/platform/bioinfo/software/abyss\n",
            "description": "Assemble short unpaired reads",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        },
        {
            "name": "WigAdd",
            "display_name": "Add",
            "version": "1.1.0",
            "summary": "\n  \nThis tool will add all values in the specified Wig files base pair by base pair.\n  \n.. class:: infomark\n\n**TIP:** If your dataset does not appear in the pulldown menu, it means that it is not in Wig or BigWig format. Use \"edit attributes\" to set the correct format if it was not detected correctly.\n   \n",
            "description": "multiple (Big)Wig files",
            "example": [],
            "links": [],
            "references": [],
            "availability": [],
            "technology": [],
            "programming_language": [],
            "license": [],
            "operating_system": [],
            "inputs": [],
            "parameters": [],
            "outputs": [],
            "quality": [],
            "learn_flow": [],
            "algorithm": []
        }
    ]

var dataAfter = [];

for(var i = 0; i < dataBefore.length; i++) {
  var item = dataBefore[i];
  for(data in item) {
    dataAfter.push({id: i, label: item[data], shape: 'circularImage', image: 'img/1.png'});
  }
}

console.log(dataAfter);


//added below for display the output
$(".results").append(JSON.stringify(dataAfter));
// create a network
      var containerr = document.getElementById('results');
      var datra = {
        nodes: dataAfter,
        edges: dataAfter
      };
      var options = {
        nodes: {
          borderWidth:4,
	      color: {
            border: '#222222',
            background: '#666666'
          },
          fontColor:'#eeeeee'
        },
        edges: {
          color: 'lightgray'
        }
      };
      network = new vis.Network(containerr, datra, options);


//=--------------------------------------------------------------=

    var DIR = 'img/soft-scraps-icons/';

    var nodes = null;
    var edges = null;
    var network = null;

    // Called when the Visualization API is loaded.
    function draw() {
      // create people.
      // value corresponds with the age of the person
      var DIR = 'img/';
      nodes = [
        {id: 1,  label:"NET BIO",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 2,  label:"ChIP-Seq (application)",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 3,  label:"ChIPmeta",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 4,  label:"ChIPMunk",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 5,  label:"CHiPSeqCHiPSeq",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 6,  label:"ChIPseqR",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 7,  label:"Chipster",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 8,  label:"ChromaSig",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 9,  label:"ChromHMM",  shape: 'circularImage', image: DIR + '1.png'},
        {id: 10,  label:"Circos", shape: 'circularImage', image: DIR + '1.png'},
        {id: 11,  label:"CisGenome", shape: 'circularImage', image: DIR + '1.png'},
        {id: 12,  label:"AGE", shape: 'circularImage', image: DIR + '1.png'},
        {id: 13,  label:"Cistrome", shape: 'circularImage', image: DIR + '1.png'},
        {id: 14,  label:"NCLCbio Genomics Workbench", shape: 'circularImage', image: DIR + '1.png'},
        {id: 15,  label:"Clean reads", shape: 'circularImage', image: DIR + '1.png'},
        {id: 16,  label:"CleaveLand", shape: 'circularImage', image: DIR + '1.png'},
        {id: 17,  label:"CLEVER", shape: 'circularImage', image: DIR + '1.png'},
        
      ];

      // create connetions between people
      // value corresponds with the amount of contact between two people
      edges = [
        {from: 1, to: 2},
        {from: 2, to: 3},
        {from: 2, to: 4},
        {from: 4, to: 5},
        {from: 4, to: 10},
        {from: 4, to: 6},
        {from: 6, to: 7},
        {from: 7, to: 8},
        {from: 8, to: 9},
        {from: 8, to: 10},
        {from: 10, to: 11},
        {from: 11, to: 12},
        {from: 12, to: 13},
        {from: 13, to: 14},
        {from: 14, to: 15},
        {from: 15, to: 16},
        {from: 16, to: 17}
      ];

      // create a network
      var container = document.getElementById('mynetwork');
      var data = {
       nodes: nodes,
       edges: edges
        
      }; 
      var options = {
        nodes: {
          borderWidth:4,
	      color: {
            border: '#ceddc2',
            background: '#89f4b0'
          },
          fontColor:'#eeeeee'
        },
        edges: {
          color: 'lightgray'
        }
      };
      network = new vis.Network(container, data, options);
      console.log(nodes);
    }
  </script>
</head>
<!--Added the onload for the tree view-->
<body onload="draw();">

<div class="wrapper">
	<div class="container">
		<h1>Tools Net</h1>
		
		<ul class="home-nav">
			<li><a href="index.html" data-id="three-columns"><img src="img/home-icon.png"></a></li>
			<li><a href="help.html" data-id="four-columns"><img src="img/tiny-question.png"></a></li>
		</ul>
	</ul>

		<hr />
		<div id="mynetwork"></div>
		
		<hr />
		
		<div class="results">
			<h2>test</h2>
		</div>
	</div>
	<!--/.container-->
</div>
<!--/.wrapper-->

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" type="text/javascript"></script>

<!--Touch_event-->
        <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
        <script src="http://code.jquery.com/ui/1.8.21/jquery-ui.min.js"></script>
         <script src="js/jquery.ui.touch-punch.min.js"></script>
         <script src="js/demo.js"></script>
		  <script src="js/index.js"></script>

        <script>$('#movable_links').draggable();$('#movable_link_1').draggable();$('#movable_link_2').draggable();$('#movable_link_3').draggable();</script>

<!--End Touch_event-->
</body>
</html>